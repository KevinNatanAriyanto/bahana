import React, { useState, useEffect } from 'react';
import { observer } from "mobx-react"
import { onSnapshot, onAction, onPatch, applySnapshot, applyAction, applyPatch, getSnapshot } from "mobx-state-tree"
import { ViewStyle, View, ImageBackground, Alert, ScrollView, Image, ImageStyle, TextStyle, TouchableOpacity, TextInput, Dimensions, Platform, Keyboard, RefreshControl, PermissionsAndroid, AppState, BackHandler } from "react-native"
import Icon from 'react-native-vector-icons/Ionicons';
import { Text, Screen, Button, Checkbox, FormRow, Header, Loading, Switch, Wallpaper, TextField, ErrorMessage, Footer, Ads } from "@components"
import { BottomDrawerCustom } from "@vendor"
import { color, layout } from "@theme"
import { Helper } from "@utils/helper"
import { NavigationScreenProps } from "react-navigation"
import { Formik } from 'formik';
import * as Yup from 'yup';
import Carousel from 'react-native-snap-carousel';
import OneSignal from 'react-native-onesignal';
import PushNotification from 'react-native-push-notification';
import { getDistance } from 'geolib';
// import BottomDrawer from 'rn-bottom-drawer';
// import { Client } from 'bugsnag-react-native';
import Toast from 'react-native-root-toast';
import { TabView, SceneMap, TabBar, SceneRendererProps } from 'react-native-tab-view';
import { useStores } from "@models/root-store"
import Reactotron from 'reactotron-react-native';
import { translate } from "@i18n"
import { CONFIG } from "@utils/config"
import moment from "moment";
import AsyncStorage from '@react-native-community/async-storage';
import Geolocation from '@react-native-community/geolocation';
import BackgroundGeolocation from '@mauron85/react-native-background-geolocation';
import BackgroundJob from 'react-native-background-job';
import BackgroundTimer from 'react-native-background-timer';
import RNMockLocationDetector from 'react-native-mock-location-detector';
const { height, width, heightWindow } = Dimensions.get('window');
const deviceHeight = Dimensions.get('window').height;
const deviceWidth = Dimensions.get('window').width;
import WifiManager from "react-native-wifi-reborn";
import Bugsee from 'react-native-bugsee';
import { checkInternetConnection, offlineActionCreators } from 'react-native-offline';
import { showMessage, hideMessage } from "react-native-flash-message";
import NetInfo from "@react-native-community/netinfo";
import DeviceInfo from 'react-native-device-info';

export interface HomeScreenProps extends NavigationScreenProps<{}> {
}

function wait(timeout) {
  return new Promise(resolve => {
    setTimeout(resolve, timeout);
  });
}

const styles = {
	img_header: {
		position: "absolute", top: 0, left: 0, width: deviceWidth
	},
	header_action: {
		position: "absolute", top: 0, right: 0, flexDirection: "row"
	},
	header_wrapper: {
		height: 140
	},
	welcome_txt: {
		fontSize: 16, marginBottom: 15, color: "#fff"
	},
	welcome_name: {
		fontSize: 24, fontWeight: "bold", marginBottom: 5, color: "#fff"
	},
	welcome_title: {
		fontSize: 12, color: "#fff"
	},
	icon: {
		width: 30, height: 30, resizeMode: "contain"
	}
}

// -------------
// Interval settings
// -------------
let general_counter = 0;
let check_general_interval = 10; // each 10s
let check_leave_current = 0;
let check_leave_interval = 18; // each 3 minutes (in tens)
let check_task_current = 0;
let check_task_interval = 30; // each 5 minutes (in tens)
let notif_atasan_current = 0; // each 5 minutes (in tens)
let notif_atasan_interval = 30; // each 5 minutes (in tens)
let stop_bugsee_current = 0; // each 5 minutes (in tens)
let stop_bugsee_interval = 18; // each 3 minutes (in tens)

let jamKantor = false
let jamIstirahat = false

export const HomeScreen: React.FunctionComponent<HomeScreenProps> = observer((props) => {
  // const { someStore } = useStores()
  	const rootStore = useStores()
  	const [loading, setLoading] = useState(false);
  	const [current_user_role, setCurrentUserRole] = useState(null);
  	const [refreshing, setRefreshing] = React.useState(false);
  	const [tasks, setTasks] = React.useState([]);
  	const [unreadNotif, setUnreadNotif] = React.useState(0);
  	const [currentCompany, setCurrentCompany] = React.useState([]);
  	const [companyLogo, setCompanyLogo] = React.useState(require('@assets/logo.png'));
  	const [notifications, setNotifications] = React.useState([]);
  	const [menuReport, setMenuReport] = React.useState(false);
  	const [menuProject, setMenuProject] = React.useState(false);
  	const [refreshOffice, setRefreshOffice] = useState(false);
  	const [watchPositionId, setWatchPositionId] = useState('');
  	const [karyawanKhusus, setKaryawanKhusus] = useState(false);
  	const [officeData, setOfficeData] = useState(null);
  	const [notifAtasan, setNotifAtasan] = useState(false);
  	const [isUpdated, setIsUpdated] = useState(false);
  	const [getPermission, setGetPermission] = useState(false);
  	const [lastClockin, setLastClockin] = useState(null);
  	const [appInBackground, setAppInBackground] = useState(true);
  	const [appState, setAppState] = useState(AppState.currentState);

	const goBack = React.useMemo(() => () => props.navigation.goBack(null), [props.navigation])

	const navigateTo = React.useMemo((routeName, params) => (routeName, params) => props.navigation.navigate(routeName, params ), [
      	props.navigation,
  	])

  	const onRefresh = React.useCallback(() => {
	    // setRefreshing(true);
	    console.log('on refresh')
	    var promises = [];

	    setLoading(true)

	    promises[0] = loadUnreadNotices();
	    promises[1] = loadProfile();
		
		// get all permissions & office locations
		// getEmployeePermission();
		// getMyLeave();
		promises[2] = getLastClockin();
		// checkLatestUpdate();

		rootStore.settings.resetOfflineMode();
		// checkInternet();
		// var checkWifi = checkWifiRadius();

		// get all core data
		promises[3] = runBackgroundInit();

		// DISABLE! DEBUG PURPOSE ONLY
		// doSync();
		// console.log('see storage my_queues')
		// console.log(rootStore.my_queues)
		// rootStore.removeData('my_queues')
		// console.log('after remove storage my_queues')
		// console.log(rootStore.my_queues)
		// console.log(rootStore.ship_schedules);

		// stop bugsee reporting
		stopReport()

		Promise.all(promises).then((values) => {
			console.log('refresh completed')

			setLoading(false)
			setRefreshing(false);
		});

	}, [refreshing]);

	useEffect( () => {
		// loadProfile();

		if(typeof rootStore.getCurrentUser().name === "undefined"){
			doLogout();
		}

		// get current user
		var cur_user = rootStore.getCurrentUser();
		
		// Bugsee.log(JSON.stringify(cur_user), Bugsee.LogLevel.Info);
		// Bugsee.showFeedbackUI();
		Bugsee.setAttribute("current_user", JSON.stringify({
			"id": cur_user.id,
			"name": cur_user.name,
			"email": cur_user.email
		}));
		Bugsee.setEmail(cur_user.email);

		// loading core data
		loadAll();

		// var checkWifi = checkWifiRadius();

		// loadUnreadNotices();

		OneSignal.init(CONFIG.ONESIGNAL_KEY, {kOSSettingsKeyAutoPrompt : true});
	  	OneSignal.addEventListener('received', onReceived);
	    OneSignal.addEventListener('opened', onOpened);
	    OneSignal.addEventListener('ids', onIds);

	    AppState.addEventListener('change', _handleAppStateChange);

	    runBackgroundProcess()

	    // BackgroundGeolocation.stop();

	    // stop running bugsee reporting
	    stopReport()

	    getTaskReminders();
	    rootStore.getAllUserInfo()

	}, []);

	const syncTime = async() => {
	    var result = await rootStore.getServerTime();

	    if(result.kind == "ok" && result.data){
		    var time = result.data.dateTime;

		    var current = moment().format("DD-MM-YYYY HH:mm");
		    var server = moment(time).format("DD-MM-YYYY HH:mm");

		    // check time late (max 5 minutes late)
		    var diff_time = moment.duration(moment().diff(moment(time))).as('minutes');

		    console.log('current: '+current)
		    console.log('server: '+server)

		    // if(moment().unix() != moment(time).unix()){
		    // if(current != server){
		    if(diff_time > 5){
		    	Toast.show("Waktu tidak sama! Silahkan sesuaikan jam device anda. Current: "+current+"; Server: "+server);

		    	setTimeout(function(){
		    		BackHandler.exitApp();
		    	}, 5000);
		    }

	    	return time;
	    }
	}

	const storageAll = async () => {

		setLoading(true)

		var promises = [];

		// save all assignees
		promises[0] = rootStore.getAllAssignees()

		// save all projects
		promises[1] = rootStore.getAllProjects()

		// save all questions
		promises[2] = rootStore.getAllQuestions()

		// save all attendances
		promises[3] = rootStore.getAllAttendances()

		// save all tasks
		promises[4] = rootStore.getAllTasks()

		// save all timelogs
		promises[5] = rootStore.getAllTimelogs()

		// save all user profile data
		promises[6] = rootStore.getAllUserInfo()

		Promise.all(promises).then((values) => {
	  		Toast.show("Download data untuk mode offline selesai")
			setLoading(false)
		});

	}

	const doSync = () => {

		if(!rootStore.settings.offline_mode){
			// Toast.show("Melakukan sinkronisasi data...")

			console.log('running pending queues')
			console.log(rootStore.my_queues)

			rootStore.startQueue();
		}

	}

	// get all downloadable content for offline usage
	const doDownload = () => {
		console.log('storage attendances')
		console.log(rootStore.attendances)
		console.log('storage tasks')
		console.log(rootStore.tasks)
		console.log('storage projects')
		console.log(rootStore.projects)
		console.log('storage timelogs')
		console.log(rootStore.timelogs)

		Alert.alert(
	      "Perhatian",
	      "Anda akan mendownload semua data untuk mode offline, proses ini membutuhkan waktu yang agak lama. Apakah anda yakin? Hanya lakukan ini apabila ada instruksi dari atasan",
	      [
	        {
	          text: "Cancel",
	          // onPress: () => console.log("Cancel Pressed"),
	          style: "cancel"
	        },
	        { text: "OK", onPress: () => storageAll() }
	      ],
	      { cancelable: false }
	    );
	}

  	const runBackgroundGPS = () => {
  		console.log('---run background gps---')

  		BackgroundGeolocation.stop()
  		BackgroundGeolocation.configure({
	      desiredAccuracy: BackgroundGeolocation.HIGH_ACCURACY,
	      notificationTitle: 'Bahana Line Group',
	      notificationText: 'Ketuk untuk membuka aplikasi',
	      debug: true,
	      startOnBoot: true,
	      stopOnTerminate: false,
	      startForeground: true,
	      saveBatteryOnBackground: false,
	      stopOnStillActivity: false,

	      // locationProvider: BackgroundGeolocation.RAW_PROVIDER,
	      
	      // locationProvider: BackgroundGeolocation.DISTANCE_FILTER_PROVIDER,
	      // stationaryRadius: 20,
	      // distanceFilter: 30,
	      // interval: 900000,
	      // fastestInterval: 450000,
	      // activitiesInterval: 900000,

	      locationProvider: BackgroundGeolocation.ACTIVITY_PROVIDER,
	      interval: 900000,
	      fastestInterval: 450000,
	      activitiesInterval: 900000,

	      // interval: 120000,
	      // fastestInterval: 60000,
	      // activitiesInterval: 120000,
	    });
			 
	    BackgroundGeolocation.on('location', async(position) => {
	    	console.log('[ON LOCATION] BackgroundGeolocation:', position);

	    	rootStore.storeGPS(position);

	    	var position = {
	    		...position,
	    		data: JSON.stringify(position)
	    	}

	    	rootStore.assignData("gps", position)
	    	
	    	// DEBUG: turn off temporary
	    	// each position changing also check the wifi
	    	// var dapatWifi = await checkWifiRadius();
    		// checkPositionValid(dapatWifi, position);
	    });

	    BackgroundGeolocation.on('stationary', async (position) => {
			// handle stationary locations here
			// Actions.sendLocation(stationaryLocation);
			console.log('[STATIONARY] BackgroundGeolocation stationary:', position);

			rootStore.storeGPS(position);

	    	var position = {
	    		...position,
	    		data: JSON.stringify(position)
	    	}

	      	rootStore.assignData("gps", position)

	      	// DEBUG: turn off temporary
	      	// each position changing also check the wifi
    		// var dapatWifi = await checkWifiRadius();
    		// checkPositionValid(dapatWifi, position);

	    });
	 
	    BackgroundGeolocation.on('error', (error) => {
	      console.log('[ERROR] BackgroundGeolocation error:', error);
	    });
	 
	    BackgroundGeolocation.on('start', () => {
	      console.log('[INFO] BackgroundGeolocation service has been started');
	    });
	 
	    BackgroundGeolocation.on('stop', () => {
	      console.log('[INFO] BackgroundGeolocation service has been stopped');
	      // AsyncStorage.removeItem('gps');
	    });
	 
	    BackgroundGeolocation.on('authorization', (status) => {
	      console.log('[INFO] BackgroundGeolocation authorization status: ' + status);
	      if (status !== BackgroundGeolocation.AUTHORIZED) {
	        // we need to set delay or otherwise alert may not be shown
	        setTimeout(() =>
	          Alert.alert('App requires location tracking permission', 'Would you like to open app settings?', [
	            { text: 'Yes', onPress: () => BackgroundGeolocation.showAppSettings() },
	            { text: 'No', onPress: () => console.log('No Pressed'), style: 'cancel' }
	          ]), 1000);
	      }
	    });
	 
	    BackgroundGeolocation.on('background', () => {
	      console.log('[INFO] App is in background');
	      setAppInBackground(true)
	    });
	 
	    BackgroundGeolocation.on('foreground', () => {
	      console.log('[INFO] App is in foreground');
	      setAppInBackground(false)
	    });
	 
	    BackgroundGeolocation.on('abort_requested', () => {
	      console.log('[INFO] Server responded with 285 Updates Not Required');
	 
	      // Here we can decide whether we want stop the updates or not.
	      // If you've configured the server to return 285, then it means the server does not require further update.
	      // So the normal thing to do here would be to `BackgroundGeolocation.stop()`.
	      // But you might be counting on it to receive location updates in the UI, so you could just reconfigure and set `url` to null.
	    });
	 
	    BackgroundGeolocation.on('http_authorization', () => {
	      console.log('[INFO] App needs to authorize the http requests');
	    });
	 
	    BackgroundGeolocation.checkStatus(status => {
	      console.log('[INFO] BackgroundGeolocation service is running', status.isRunning);
	      console.log('[INFO] BackgroundGeolocation services enabled', status.locationServicesEnabled);
	      console.log('[INFO] BackgroundGeolocation auth status: ' + status.authorization);
	 
	      // you don't need to check status before start (this is just the example)
	      if (!status.isRunning) {
	        BackgroundGeolocation.start(); //triggers start on start event
	      }
	    });
	    
		// BackgroundGeolocation.start();
  	}

  	const checkInternet = async() => {
  		var netinfo = await NetInfo.fetch();
		console.log("internet connected? "+netinfo.isConnected);

		var settings = rootStore.getData('settings')

		if(netinfo.isConnected){
			rootStore.assignData("settings", { offline_mode: false })
			hideMessage();

			// start the queue
			// myqueue.start()
		}else{
			rootStore.assignData("settings", { offline_mode: true })

			// set updated and get permission
			setGetPermission(true);
			setIsUpdated(true);

			// only displaying the message once
			if(!settings.offline_mode){
				Helper.offlineMsg(true);
			}
		}
  	}

  	const runBackgroundInit = async () => {

  		try{
	  		runBackgroundGPS();
	  		getMyLeave();
			await getEmployeePermission();
			checkInternet();
			syncTime();
	  		// checkLatestUpdate();

			var dapatWifi = await checkWifiRadius();
			BackgroundGeolocation.checkStatus(async (status) => {
	      		console.log('[INFO] BackgroundGeolocation service is running: '+status.isRunning);
	      		console.log('[INFO] BackgroundGeolocation services enabled: '+status.locationServicesEnabled);

	      		var dapatGps = null;

	      		if(status.locationServicesEnabled){
	      			// get storage if gps is enabled
	      			dapatGps = rootStore.getData('gps');
	  			}else{
	  				// remove storage on gps disabled
	  				rootStore.removeData('gps');
	  			}

				checkPositionValid(dapatWifi, dapatGps);
	  		});

  		}catch(e){
			console.log('error')
			console.log(e)

			if(e.code){
				switch(e.code){
			    	case "locationServicesOff":
			    		Toast.show("Anda belum menyalakan GPS");
			    		showNotif(2, "gpserror", "Segera menyalakan GPS anda", "Tidak bisa mendapatkan lokasi");

			    	break;
			    	case "locationPermissionMissing":
			    		Toast.show("Anda belum mengijinkan pemakaian GPS");
			    	break;
			    }
		    }
		}
  	}

  	const runBackgroundProcess = async () => {

  		// run init process
  		// runBackgroundInit();

  		runBackgroundGPS();
  		syncTime();

	  	BackgroundTimer.stopBackgroundTimer(); //after this call all code on background stop run.
	    BackgroundTimer.runBackgroundTimer(async() => {

	    	general_counter++;

	    	var array = []
			// Reactotron.log('jalanBackgroundTimer 2')
			var WifiEntry;

			try{
				// ---------------------
				// syncing pending queues
				// ---------------------
				doSync();

				// ---------------------
				// stopping bug reporting
				// ---------------------
				stop_bugsee_current++;
				if(stop_bugsee_current == stop_bugsee_interval){

					stopReport();

					stop_bugsee_current = 0;
				}

				// ---------------------
				// checking internet connection
				// ---------------------
				checkInternet();

				// ---------------------
				// reminder interval activity report
				// ---------------------
				check_task_current++;
				if(check_task_current == check_task_interval){

					// refresh new task reminder
					getTaskReminders();

					// reset the counter
					check_task_current = 0;
				}

				doRemindTasks();
				

				// ---------------------
				// check application version & server time
				// ---------------------
				checkLatestUpdate();

				// ---------------------
				// check leave status
				// IMPORTANT: CANNOT UPDATE LAYERS WHEN ON BACKGROUND / APP KILL
				// ---------------------
	      		check_leave_current++;
		    	if(check_leave_current == check_leave_interval){

		    		// if(!appInBackground){

		    			// temporary relocation
			    		// console.log('check leave status')
			    		// await getMyLeave();
			    		// await getEmployeePermission();

			    	// }

		    		// reset the counter
		    		check_leave_current = 0;
		    	}

		    	// every 60s
		    	if(general_counter % 6 == 0){

		    		console.log('check leave status')
		    		syncTime();
		    		await getMyLeave();
		    		await getEmployeePermission();

		    		console.log('check wifi status')

					// ---------------------
					// cek wifi
					// ---------------------
					var dapatWifi = await checkWifiRadius();

					// ---------------------
					// cek gps
					// ---------------------
					BackgroundGeolocation.checkStatus(async (status) => {
			      		console.log('[INFO] BackgroundGeolocation service is running: '+status.isRunning);
			      		console.log('[INFO] BackgroundGeolocation services enabled: '+status.locationServicesEnabled);

			      		var dapatGps = null;

			      		if(status.locationServicesEnabled){
			      			// get storage if gps is enabled
			      			dapatGps = rootStore.getData('gps');
		      			}else{
		      				// remove storage on gps disabled
		      				rootStore.removeData('gps');
		      			}

		    			checkPositionValid(dapatWifi, dapatGps);
		      		});
				}

			}catch(e){
				console.log('error')
				console.log(e)

				if(e.code){
					switch(e.code){
				    	case "locationServicesOff":
				    		Toast.show("Anda belum menyalakan GPS");
				    		showNotif(2, "gpserror", "Segera menyalakan GPS anda", "Tidak bisa mendapatkan lokasi");

				    	break;
				    	case "locationPermissionMissing":
				    		Toast.show("Anda belum mengijinkan pemakaian GPS");
				    	break;
				    }
			    }
			}
	    }, (check_general_interval*1000))
	}

	const checkLatestUpdate = async () => {
		console.log('checking latest application update')
		var is_apps_latest = true;

		// always set flag as updated for development environment
		// if(CONFIG.ENVIRONMENT == "production"){
			// var settings = await AsyncStorage.getItem('settings');
			var settings = rootStore.getData("settings");
			// var settings_data = (settings.data) ? JSON.parse(settings.data) : null;

			var config_notif = {
				duration: (check_general_interval*1000),
				position: -100,
				hideOnPress: false
			}

			if(settings.update_version && settings.application_version){
				if(settings.update_version != CONFIG.APP_VERSION){
					is_apps_latest = false;
					Toast.show("Aplikasi belum terupdate. Restart aplikasi untuk mendapatkan update terbaru ("+settings.update_version+")", config_notif)
				}else if(settings.application_version != DeviceInfo.getVersion()){
					is_apps_latest = false;
					Toast.show("Anda masih menggunakan aplikasi versi lama. Hubungi admin untuk mendapatkan versi baru ("+settings.application_version+")", config_notif)
				}
				setIsUpdated(is_apps_latest)
			}
		// }else{
		// 	setIsUpdated(is_apps_latest)
		// }
	}

	const checkPositionValid = async (wifiAccess, gpsAccess) => {
		var valid = false;
		var error_type = 0;
		const my_attendance = rootStore.getData('my_attendance')

		// ---------------------
	    // cek apakah user tidak perlu absensi atau tidak
	    // ---------------------
	    const valueDesignation = rootStore.getData('my_designation')

	    // if(valueDesignation != null && valueDesignation.id && !valueDesignation.check_late || !rootStore.my_permission.is_required_absence){
	    if(!rootStore.my_permission.is_required_absence){
	    	console.log("user tidak perlu absen");
	    	valid = true;
	    }

	    // ---------------------
	    // cek cluster kantor untuk menentukan jam kantor atau tidak
	    // ---------------------
	    const valueCluster = rootStore.getData('cluster')

	    if(!valid && valueCluster !== null && valueCluster.name) {
			var storage = valueCluster

			// check if user is on shift mode or clustered office
			if(storage.start_hour && storage.end_hour && storage.start_hour != 'null' && storage.end_hour != 'null' && !!storage.start_hour && !!storage.end_hour && storage.start_hour !== null && storage.end_hour !== null){

				console.log('run shift mode')

				// run shift mode
				var office_start = moment(storage.start_hour, "HH:mm A").format("YYYY-MM-DD HH:mm");
	            var office_end = moment(storage.end_hour, "HH:mm A").format("YYYY-MM-DD HH:mm");
	            var break_start = moment(storage.istirahat_awal, "HH:mm A").format("YYYY-MM-DD HH:mm");
	            var break_end = moment(storage.istirahat_akhir, "HH:mm A").format("YYYY-MM-DD HH:mm");
	            
	            console.log("jam kantor shift: "+office_start+" - "+office_end)

	            jamKantor = false;
	            if(moment().isBetween(office_start, office_end)){
	            	console.log("berada pada jam kantor shift")
	                jamKantor = true;
	            }

	            if(!!storage.istirahat_awal && !!storage.istirahat_akhir){

		            jamIstirahat = false;
		            if(moment().isBetween(break_start, break_end)){
		            	console.log("berada pada jam istirahat")
		                jamIstirahat = true;
		            }
	            }
            }else{

            	// run clustered
            	// var jadwal_today = JSON.parse(storage.jadwal_today);

            	if(!!storage.jadwal_today){
            		console.log('run clustered mode')
            		console.log(storage.jadwal_today)

	            	var jadwal_today = storage.jadwal_today;

	            	var office_start = moment(jadwal_today.jam_masuk, "HH:mm A").format("YYYY-MM-DD HH:mm");
		            var office_end = moment(jadwal_today.jam_pulang, "HH:mm A").format("YYYY-MM-DD HH:mm");
		            var break_start = moment(jadwal_today.istirahat_awal, "HH:mm A").format("YYYY-MM-DD HH:mm");
		            var break_end = moment(jadwal_today.istirahat_akhir, "HH:mm A").format("YYYY-MM-DD HH:mm");

		            console.log("jam kantor cluster: "+office_start+" - "+office_end)

		            jamKantor = false;
		            if(moment().isBetween(office_start, office_end)){
		            	console.log("berada pada jam kantor cluster")
		                jamKantor = true;
		            }

		            if(!!jadwal_today.istirahat_awal && !!jadwal_today.istirahat_akhir){

			            jamIstirahat = false;
			            if(moment().isBetween(break_start, break_end)){
			            	console.log("berada pada jam istirahat")
			                jamIstirahat = true;
			            }
		            }
		        }
            }
		}
		// console.log('pada jam kantor? '+jamKantor);

		// check whether wifi is available nearby
		if(!valid && wifiAccess && typeof wifiAccess == 'boolean'){
    		console.log('wifi is available nearby');
    		valid = true;
    	}

		const valueOffice = rootStore.getData('office')
    	console.log('storage office')
    	console.log(valueOffice)

    	// console.log('gps access')
    	// console.log(gpsAccess)

    	// checking if user doing WFH or office qrcode
    	if(!valid && valueOffice != null && valueOffice.name && gpsAccess) {
    		console.log('user is doing WFH or office qrcode')

    		// get data from user office storage
			storage = valueOffice
			var data = {
	    		office : storage.name,
	    		accuracy: 0
	    	}

	    	// step 2. start checking gps when wifi nearby not detected or wifi nearby not valid
	    	if(!valid){
		    	if(gpsAccess && gpsAccess.longitude && gpsAccess.latitude){

		    		// if(typeof gpsAccess == 'string'){
		    		// 	gpsAccess = JSON.parse(gpsAccess);
	    			// }

		    		console.log('get gps access');
		    		console.log(gpsAccess);

					var office_distance = getDistance(
					    { latitude: gpsAccess.latitude, longitude: gpsAccess.longitude },
					    { latitude: (storage.latitude) ? storage.latitude : 0, longitude: (storage.longitude) ? storage.longitude : 0 }
					);

					data.accuracy = parseFloat(gpsAccess.accuracy).toFixed(2);
					var jarak_ke_kantor = (storage.wfh) ? 35 : (storage.radius) ? storage.radius : null;
					
					console.log('office_distance: '+ office_distance)
					console.log('jarak_ke_kantor: '+ jarak_ke_kantor)

					if(!!office_distance && !!jarak_ke_kantor && (office_distance > jarak_ke_kantor)){

						// pada jam kantor dan diluar kantor
						if(jamKantor){
							console.log("user diluar kantor pada jam kantor")

							if(storage.wfh){
								console.log("user melakukan WFH")
							}

							error_type = 1;
							data.distance_diff = parseInt(office_distance) - parseInt(jarak_ke_kantor);
							data.office_distance = office_distance;
							data.jarak_ke_kantor = jarak_ke_kantor;

						}else{
							console.log("user didalam kantor diluar jam kantor")

							// pada jam kantor dan didalam kantor
							valid = true;
						}
					}else if(!office_distance || !jarak_ke_kantor){
						console.log('tidak ada jarak ke kantor');
					}else{
						console.log("user didalam kantor")
						valid = true;
					}
				}
			}
		}

		// user doing karyawan khusus (only need enable gps)
		else if(!valid && valueOffice != null && !valueOffice.name && gpsAccess){
			console.log('user as karyawan khusus and has gps access')
			valid = true;
		}

		if(jamKantor){
			// console.log('user berada pada lokasi: '+valid);
			console.log("pada jam kantor")
			console.log(my_attendance)

			if(my_attendance && my_attendance.clock_in_time){
				console.log("sudah absen masuk")
				// valid = true
			}else{
				console.log("belum absen masuk")
				error_type = 3;
				valid = false;
			}

			if(my_attendance && my_attendance.clock_out_time){
				console.log("sudah absen keluar")
				error_type = 2;
				valid = false;
			}

		}else{
			console.log('diluar jam kantor')
			valid = true;
		}

		// pengecualian untuk jam istirahat
		if(jamIstirahat){
			valid = true;
		}

		// 3. start checking for leave allow status
		var leaves = rootStore.getData('my_leaves');

		if(!valid){
			if(leaves && leaves != "" && leaves.length > 0){
				var have_leave = false;
				console.log("melihat semua ijin user");

				var date_now = moment().format();

				leaves.map((item,i) => {
					if(item.id){
						var start_date = moment(item.leave_date.toString()).format("YYYY-MM-DD");
						// var item_child = JSON.parse(item.child);
						var item_child = item.child;

						if(item_child && item_child.start_hour){
							start_date += " "+item_child.start_hour;
						}else{
							start_date += " 00:00:00";
						}
						start_date = moment(start_date);

						var end_date = moment(item.leave_date_end.toString()).format("YYYY-MM-DD");
						if(item_child && item_child.end_hour){
							end_date += " "+item_child.end_hour;
						}else{
							end_date += " 23:59:59";
						}
						end_date = moment(end_date);

						var is_between = moment().isBetween(start_date, end_date);

						if(is_between){
							valid = true;
							have_leave = true;
						}
					}
				});

				console.log('saat ini user punya ijin: '+have_leave);
			}else{
				console.log("user tidak mempunyai ijin")
			}
		}

		// 4. checking if user have extra access for none notification
		// NOT USED DUE TO POLICY CHANGED
		/*
		console.log('checking user permission from supervisor')
		var employee = rootStore.getData('employee');

		if(!!employee){
			var employee_data = JSON.parse(employee.data);

			if(!valid && employee_data && employee_data != ""){
				if(employee.no_notification){

					// check the date allowed
					if(employee.no_notification_start && employee.no_notification_end){
						var start_date = moment(employee.no_notification_start);
						var end_date = moment(employee.no_notification_end);

						var is_between = moment().isBetween(start_date, end_date);

						if(is_between){
							console.log("user punya ijin khusus dari atasan")
							valid = true;
						}
					}else{
						console.log("user tidak punya ijin khusus dari atasan")
					}

				}else{
					console.log("user tidak punya ijin khusus dari atasan")
				}
			}
		}
		*/

		// disable ALL checking when no internet connection available
		var settings = rootStore.getData('settings');
		if(settings.offline_mode){
			valid = true;
		}

		if(!valid && jamKantor){
			console.log('error type: '+error_type);

			switch(error_type){
				case 0:
					var title = "Tidak bisa mendapatkan lokasi";
					var str = "Cek koneksi GPS & Wifi Anda dan tunggu beberapa saat";
					console.log(title+". "+str)

					showNotif(0, "locationoff", title, str);
				break;

				case 1:
					var office_title = (data.office) ? data.office : "(Unknown)"
					var title = "Segera kembali ke "+office_title;
					var str = "Anda sudah keluar "+data.office_distance+"m dari radius kantor "+data.jarak_ke_kantor+"m. Ketepatan GPS dalam "+data.accuracy+" m";
					console.log(title+". "+str)

					if(data.accuracy < 50){
						showNotif(1, "outsideradius", title, str)

						console.log("notif atasan setiap/setelah 5 menit masih keluar radius");
						if(notif_atasan_current >= notif_atasan_interval){
							notifAtasanApi()
							notif_atasan_current = 0;
						}else{
							notif_atasan_current++;
						}
					}
				break;

				case 2:
					var title = "Pemberitahuan pulang lebih awal";
					var str = "Anda masih berada pada jam kantor dan sudah absen pulang. Silahkan lakukan absen masuk kembali.";
					console.log(title+". "+str)

					showNotif(2, "checkoutinofficehour", title, str);
				break;

				case 3:
					var title = "Segera Absen";
					var str = "Anda masih berada di dalam periode jam kantor";
					console.log(title+". "+str)

					showNotif(3, "inofficehour", title, str);
				break;

				default:
					// showNotif(0, "locationoff", "Tidak bisa mendapatkan lokasi", "Nyalakan GPS & Wifi Anda");
				break;
			}
		}
	}

	const showNotif = (id, tag, title, message) => {
		PushNotification.localNotification({
        	id: id.toString(),
			// bigText: "Anda keluar dari radius "+params.office+", jarak anda dengan "+params.office+" adalah "+params.office_distance+" m", // (optional) default: "message" prop
			// bigText: "Tidak bisa mendapatkan lokasi", // (optional) default: "message" prop
			// subText: "Segera menyalakan GPS anda", // (optional) default: none
			tag: tag, // (optional) add tag to message
			group: tag, // (optional) add group to message
			ongoing: false, // (optional) set whether this is an "ongoing" notification
			priority: "high", // (optional) set notification priority, default: high
			visibility: "private", // (optional) set notification visibility, default: private
			importance: "high", // (optional) set notification importance, default: high
			// allowWhileIdle: true, // (optional) set notification to work while on doze, default: false
			ignoreInForeground: false, // (optional) if true, the notification will not be visible when the app is in the foreground (useful for parity with how iOS notifications appear)
			title: title, // (optional)
			message: message, // (required)
			playSound: false, // (optional) default: true
			vibrate: false,
			vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
			// repeatType: "time",
			// repeatTime: 10000,
			// date: new Date(Date.now())
    	})
	}

  	const loadProfile = async () => {
	  	// get new data of user profile
		// setLoading(true);
	    var result = await rootStore.getCurrentProfile();
	    // setLoading(false);

	    // Reactotron.log(result.data);

	    if(result.kind == "ok" && result.data){
	    	rootStore.assignCurrentUser(result.data);
	    }
	}

	const notifAtasanApi = async(params) => {
	    var result = await rootStore.notifyAtasanKeluarRadius();

	    if(result.kind == "ok"){
	      
	    }
	}	

	const loadAll = () => {
		setLoading(true);

		var promises = []

		promises[0] = getEmployeePermission();
		promises[1] = getMyLeave();
		promises[2] = getLastClockin();
		promises[3] = loadUnreadNotices();

		// check internet connection
	    rootStore.settings.resetOfflineMode();
	    promises[4] = checkInternet();

	    // promises[5] = checkLatestUpdate();

		Promise.all(promises).then((values) => {
			console.log('initial loading completed')
			setLoading(false);
		});
	}

	const _handleAppStateChange = (nextAppState) => {
		Reactotron.log('_handleAppStateChange')
		Reactotron.log(appState)
		Reactotron.log(nextAppState)
		if(!CONFIG.DEBUG_MOCK_LOCATION){
		    RNMockLocationDetector.checkMockLocationProvider(
		        "Mock Location Detected",
		        "Please remove any mock location app first to continue using this app.",
		        "I Understand"
		        ); 
			}
	    if (nextAppState === 'active') {
	      Reactotron.log('App has come to the foreground!')
	    }
	    // this.setState({appState: nextAppState});
  	}

	// useEffect( () => {
		// BackgroundJob.cancelAll()
		//   .then(() => Reactotron.log("Success cancelAll"))
		//   .catch(err => Reactotron.log(err));

		// setOfficeStorage(officeData)

		// setStorage("office",officeData)
	// }, [officeData]);

	const checkWifiRadius = async () => {
		var check_result = false;

		console.log("check wifi radius");

		// only check wifi when the user already logged in
	    const valueOffice = rootStore.getData('office')
	    var storage = valueOffice

	    console.log("getting office storage:");
	    console.log(storage);

		if(valueOffice != null && valueOffice.name) {

			try{
				// const granted = await PermissionsAndroid.request(
				//       PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
				//       {
				//         title: 'Location permission is required for WiFi connections',
				//         message:
				//           'This app needs location permission as this is required  ' +
				//           'to scan for wifi networks.',
				//         buttonNegative: 'DENY',
				//         buttonPositive: 'ALLOW',
				//       },
				// );
				// if (granted === PermissionsAndroid.RESULTS.GRANTED) {

				const enabled = await WifiManager.isEnabled();
				console.log("wifi is "+enabled);

				if(enabled){
					WifiEntry = await WifiManager.loadWifiList();
					// WifiEntry = await WifiManager.reScanAndLoadWifiList();

					// there are nearby wifi available
					var nearby_wifis = [];
					if(WifiEntry){

						console.log("got nearby wifis");
						console.log(WifiEntry);

						// get all nearby wifi bssid
						JSON.parse(WifiEntry).map((item,i) => {
							nearby_wifis.push(item.BSSID);
						});

						// check registered office wifi with nearby
						if(!!storage.wifi && storage.wifi.length && storage.wifi.length > 0){
							console.log('stored wifi list')
							console.log(storage.wifi);

							storage.wifi.map((item,i) => {
								if(nearby_wifis.includes(item.bssid)){
									check_result = true;
								}
							});
						}
				    }
			    }

			    // }

			    console.log("user is within wifi radius: "+check_result);

			    return check_result;

		    }catch(error){
			    console.log("wifi error");
			    console.log(error);

			    switch(error.code){
			    	case "locationServicesOff":
			    		Toast.show("Anda belum menyalakan GPS");
			    		showNotif(2, "gpserror", "Segera menyalakan GPS anda", "Tidak bisa mendapatkan lokasi");
			    	break;
			    	case "locationPermissionMissing":
			    		Toast.show("Anda belum mengijinkan pemakaian GPS");
			    	break;
			    }
			  }
		}
	}
	const setStorage = (item, val) => {
	    try {
	      if(val && val != ''){
	        console.log('storage '+item+' have value!')

	        if(Array.isArray(val)){
	        	rootStore.pushData(item, val);
	        }else{
		        const jsonVal = JSON.stringify(val)
		        val = {
		        	...val,
		        	data: JSON.stringify(val)
		        }

		        rootStore.assignData(item, val);
		    }

	      }else{
	        console.log('removing '+item+'!')

	        rootStore.removeData(item)
	      }
	    } catch (e) {
	      // saving error
	      console.error(e)
	    }
  	}

  	const resetStorages = () => {
  		console.log('resetting storages')
  		
  		// reset all existing storages
    	setStorage('settings', '')
    	setStorage('my_attendance', '')
    	setStorage('my_designation', '')
    	setStorage('employee', '')
    	setStorage('cluster', '')
    	setStorage('office', '')
    	setStorage('ship', '')
    	setStorage('ship_schedules', '')
  	}

	const getEmployeePermission = async () => {

		// setLoading(true);
        var result = await rootStore.getEmployeePermission();
        // setLoading(false);

        if(result.kind == "ok" && result.data){

        	// reset all existing storages
        	resetStorages();

        	// save settings to storage
        	if(result.data.setting){
        		var res = {
        			application_version: result.data.setting.general_setting.application_version,
        			update_version: result.data.setting.general_setting.update_version
        		}

        		setStorage('settings', res);

        		await checkLatestUpdate();
    		}

    		// save employee info to storage
        	if(result.data.attendance){
        		var att = [];
        		att.push(result.data.attendance)
        		var arr = rootStore.saveAttendanceFormat(att)
        		setStorage('my_attendance', arr[0]);
        	}
        	if(result.data.designation){
        		setStorage('my_designation', result.data.designation);
        	}
        	if(result.data.permission){
        		setStorage('my_permission', result.data.permission);
        	}
        	if(result.data.employee){
        		setStorage('employee', result.data.employee);
    		}
    		if(result.data.kapal_assigned){
        		setStorage('ship', result.data.kapal_assigned);
    		}

    		if(result.data.schedule_kapal){
        		setStorage('ship_schedules', result.data.schedule_kapal);
    		}

        	setGetPermission(true);

            var menuProject = (result.data.permission.list_proyek == 1) ? true : false
            setMenuProject(menuProject)
            var menuReport = (result.data.permission.report_task == 1) ? true : false
            setMenuReport(menuReport)
            var karyawanKhusus = (result.data.permission.karyawan_khusus == 1) ? true : false
            setKaryawanKhusus(karyawanKhusus)
            if(result.data.cluster){
		        var cluster = result.data.cluster
            	setStorage("cluster", cluster)
		      }

		    // if(!result.data.office){
		    // 	setStorage('office', '')
		    // }

		    // if user checkin using qrcode
            if(result.data.office){
            	var office = result.data.office
            	// setOfficeData(office)
            	setStorage('office', office)
            }

            // if user doing WFH
            else if((result.data.attendance)&&(result.data.attendance.clock_in_time)&&(!result.data.attendance.clock_out_time)&&(result.data.attendance.working_from == 'WFH')){
            	var data_wfh = {
                  wfh:true,
                  latitude:result.data.employee.latitude,
                  longitude:result.data.employee.longitude,
                  name:'WFH'
                }
                // setOfficeData(data_wfh)
                setStorage('office', data_wfh)
            }
            
            rootStore.setCurrentUser("permissions", JSON.stringify(result.data.permission));
        }
    }

    const doRemindTasks = async () => {

    	var tasks = await AsyncStorage.getItem('task_reminders');
    	tasks = JSON.parse(tasks);

		if(tasks && tasks != "" && tasks.length > 0){
			tasks.map((item,i) => {

				if(item.interval_report != 0 && (general_counter % (item.interval_report / check_general_interval) == 0)){
					var title = "Waktunya melaporkan tugas '"+item.heading+"'";
					var description = "Sertakan bukti pelaporan sesuai instruksi pada aplikasi";

					showNotif(item.id, "remindtasks", title, description)
				}

			});
		}
    }

    const getTaskReminders = async () => {
        
    	var params = {
    		interval: true,
    		board_column_id: 5,
    		assignee_user_id: 'diri_sendiri'
    	};

        setLoading(true);
        var result = await rootStore.getTasks(params);
        setLoading(false);

        if(result.kind == "ok" && result.data && result.data.task){

        	var jsonValue = [];

        	result.data.task.map((item,i) => {
	        	jsonValue.push({
	        		id: item.id,
	        		heading: item.heading,
	        		start_date: item.start_date,
	        		due_date: item.due_date,
	        		status: item.status,
	        		board_column_id: item.board_column_id,
	        		interval_report: item.interval_report
	        	});
        	});

        	if(jsonValue.length > 0){
        		jsonValue = JSON.stringify(jsonValue);
	        	await AsyncStorage.setItem('task_reminders', jsonValue);
	        }
        }
    }

    const getMyLeave = async () => {

    	// reset all leave
    	rootStore.removeData('my_leaves');

    	var param = {
    		date: moment().format('YYYY-MM-DD')
    	}
        
        // setLoading(true);
        var result = await rootStore.getCheckMyLeave(param);
        // setLoading(false);

        if(result.kind == "ok" && result.data && result.data.leave){
        	// Reactotron.log(result);

        	var data = result.data.leave;
        	// data[0].child = JSON.stringify(data[0].child)

        	// var data = {
        	// 	...result.data.leave,
        	// 	data: result.data.leave
        	// }
        	// setStorage('my_leaves', data)

        	setStorage('my_leaves', data)
        	// await AsyncStorage.setItem('my_leaves', JSON.stringify(result.data.leave));
        }
    }

    const getLastClockin = async () => {
    	var params = {

    	};
        
        // setLoading(true);
        var result = await rootStore.getAbsenceHistory(params);
        // setLoading(false);

        if(result.kind == "ok" && result.data){

        	if(result.data.attendance.length > 0 && !result.data.attendance[0].clock_out_time){
	        	setLastClockin(result.data.attendance[0]);
	        }else{
	        	setLastClockin(null);
	        }
        }
    }

	const loadUnreadNotices = async () => {

		// setLoading(true);
		var param = {
			
		}
		var result = await rootStore.getUnreadNotice(param);
		// setLoading(false);

		if(result.kind == "ok" && result.data.count_notif > 0){
			setUnreadNotif(result.data.count_notif)
		}
	}

	const doLogout = () => {
		rootStore.removeCurrentUser();
		navigateTo("login");
	}

	const onReceived = (notification) => {
	  	Reactotron.log("Notification received: ", notification);

	  	var payload = notification.payload;
	    var data = notification.payload.additionalData;
		
		Reactotron.log("payload : ", payload);
		Reactotron.log("data : ", data);

		var param = {
			id: data.id,
			type: data.type,
			heading: payload.title,
			description: payload.body,
			created_at: new Date().toString(),
		};

		doSaveNotif(param);
	}

	const doSaveNotif = async (param) => {
		setLoading(true);
		var result = await rootStore.setNotification(param);
		setLoading(false);
	}

	const onOpened = (openResult) => {
	  	console.log('Message: ', openResult.notification.payload.body);
	    console.log('Data: ', openResult.notification.payload.additionalData);
	    console.log('isActive: ', openResult.notification.isAppInFocus);

	    Reactotron.log('openResult: ', openResult);

	    var payload = openResult.notification.payload;
	    var data = openResult.notification.payload.additionalData;

		if(openResult.action.actionID != "cancel"){
			switch(data.type){
				case "TASK":
					navigateTo("task_detail", {id: data.id, onBack: onRefresh})
				break;
				case "TIMELOG":
					navigateTo("work_report_detail", {id: data.id, onBack: onRefresh})
				break;
			}	
		}

	    // if(!data.reff_type){
	    // 	Reactotron.log("general broadcast");
	    // 	Reactotron.log(payload);

	    // 	setTimeout(function(){
	    // 		// Alert.alert(payload.title, payload.body);
	    // 		navigateTo("notif", {data: data});
    	// 	}, 1000);
	    // }
	    

	}

	const onIds = (device) => {
	  	console.log('Device info: ', device);
	  	rootStore.setCurrentUser("device_token", device.pushToken);
	}

	const formatDate = (datenow) => {
	    return moment(datenow).calendar(null, {
	      sameElse: 'MMMM Do YYYY, h:mm:ss a'
	    })
  	}

  	const absencePage = () => {
		props.navigation.navigate("absence_history",{onGoBack: () => refreshingOffice()});
	}

	const workReportPage = () => {
		navigateTo("work_report_list",{onGoBack: () => refreshingOffice()});
	}

	const refreshingOffice = () => {
		loadAll();

		// setRefreshOffice(!refreshOffice)
	}

	const doReport = async () => {
		await launchBugsee();
		Toast.show("Anda sekarang dapat melaporkan masalah. Tekan tombol di sebelah kanan jika ingin menyudahi pelaporan masalah.", {
			duration: Toast.durations.LONG
		})

		// Bugsee.showReportDialog();
	}

	const stopReport = () => {
		Bugsee.stop();
	}

	const launchBugsee = async () => {
	    let appToken;
	    var bugseeOptions;

	    if (Platform.OS === 'ios') {
	        appToken = '';
	        bugseeOptions = new Bugsee.AndroidLaunchOptions();
	        
	    } else {
	        appToken = CONFIG.BUGSEE_KEY;
	        bugseeOptions = new Bugsee.AndroidLaunchOptions();
	        bugseeOptions.notificationBarTrigger = false;
	        bugseeOptions.shakeToTrigger = false;
	    }

	    bugseeOptions.maxRecordingTime = 320;

	    await Bugsee.launch(appToken, bugseeOptions);

	    // set in app version
	    Bugsee.setAttribute("app_version", CONFIG.APP_VERSION);
  	}

	// useEffect( () => {
		
	// } , [refreshOffice])

  	return (
	    <View style={layout.container.general}>
			<Loading loading={loading} />
		
			<ScrollView
				refreshControl={
		          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
		        }
			>
				<Image style={styles.img_header} source={require("@assets/home-header.png")} />
				
				<View style={{ ...layout.container.wrapper, ...layout.container.bodyView, marginTop: 40, minHeight: deviceHeight*0.65 }}>
					<View style={styles.header_wrapper}>
						<View>
							<Text style={styles.welcome_txt}>Selamat Datang,</Text>
							<Text style={styles.welcome_name}>{rootStore.getCurrentUser().name}</Text>
							{/*<Text style={styles.welcome_title}>Supervisor Logistik</Text>*/}

							{(rootStore.employee.is_abk && rootStore.ship && rootStore.ship.name && rootStore.ship_schedules.length > 0 &&
								<View style={{ marginBottom: 10 }}>
									<Text style={{ ...layout.typography.body, color: "#fff", fontSize: 12 }}>Anda ditugaskan pada kapal {rootStore.ship.name}</Text>
									<Text style={{ ...layout.typography.body, color: "#fff", fontSize: 12, marginBottom: 10 }}>Pada: {moment(rootStore.ship_schedules[0].date_start).format('DD/MM/YYYY')} - {moment(rootStore.ship_schedules[0].date_end).format('DD/MM/YYYY')}</Text>
								</View>
							)}

							{(rootStore.employee.is_abk && rootStore.ship && !rootStore.ship.name &&
								<Text style={{ ...layout.typography.body, color: "#fff", fontSize: 12, marginBottom: 10 }}>Anda belum ditugaskan ke kapal, silahkan hubungi HRD kapal & PC.</Text>
							)}

							{(lastClockin &&
								<View style={{ marginBottom: 20 }}>
									<Text style={{ ...layout.typography.body, color: "#fff", fontSize: 12 }}>Terakhir absen masuk pada: {moment(lastClockin.clock_in_time.toString()).format("DD MMM YYYY LTS")}</Text>

									<TouchableOpacity onPress={absencePage} style={{ flexDirection: "row" }}>
										<Text style={{ ...layout.typography.body, fontSize: 12, color: "#fff", textDecorationLine: "underline"}}>Ingin absen pulang?</Text>
									</TouchableOpacity>
								</View>
							)}
							
						</View>

						<View style={styles.header_action}>
							{/*
							<TouchableOpacity onPress={() => doSync()} style={{ marginRight: 10 }}>
								<Icon name="ios-sync" size={30} style={{ color: "#fff" }} />
							</TouchableOpacity>
							*/}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity onPress={() => doDownload()} style={{ marginRight: 10 }}>
									<Image source={require("@assets/internet.png")} style={{ ...styles.icon }} />
								</TouchableOpacity>
							)}
							{(isUpdated && !rootStore.getData("settings").offline_mode) &&
								<TouchableOpacity onPress={() => navigateTo("notif")}>
									<Image source={require("@assets/ico-bell-white.png")} style={{ ...styles.icon }} />
								</TouchableOpacity>
							}
							<TouchableOpacity onPress={() => navigateTo("profile", { jamKantor: jamKantor, jamIstirahat: jamIstirahat })} style={{ marginLeft: 10 }}>
								<Image source={require("@assets/ico-gear-white.png")} style={{ ...styles.icon }} />
							</TouchableOpacity>
						</View>
					</View>

					{(unreadNotif > 0 && isUpdated &&
						<TouchableOpacity onPress={() => navigateTo("notif")} style={{ ...layout.alert.wrapper, ...layout.alert.info, marginBottom: 20 }}>
							<Text style={layout.alert.text}>Anda mempunyai {unreadNotif} pemberitahuan penting. Lihat di sini.</Text>

							{/*
							<TouchableOpacity style={layout.alert.close}>
								<Icon name="ios-close" style={{ color: "#535353" }} size={20} />
							</TouchableOpacity>
							*/}
						</TouchableOpacity>
					)}

					{( (!getPermission || !isUpdated) &&
						<Text style={{ marginTop: 120, fontSize: 10, textAlign: "center" }}>Gagal mendapatkan data dari server.{"\n"}Silahkan refresh halaman</Text>
					)}
					{( (getPermission && isUpdated) &&
						<View style={{ ...layout.menu.wrapper, ...layout.menu.grid, width: "100%", marginLeft: -10 }}>
							<TouchableOpacity style={layout.menu.box} onPress={absencePage}>
								<Image style={layout.menu.img} source={require("@assets/ico-attendance.png")} />
								<Text style={layout.menu.txt}>Absensi</Text>
							</TouchableOpacity>

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("form_pengajuan")}>
									<Image style={layout.menu.img} source={require("@assets/ico-approve.png")} />
									<Text style={layout.menu.txt}>Pengajuan</Text>
								</TouchableOpacity>
							)}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("pengajuan")}>
									<Image style={layout.menu.img} source={require("@assets/ico-status.png")} />
									<Text style={layout.menu.txt}>Status</Text>
								</TouchableOpacity>
							)}

							{/*
							<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("projects")}>
								<Image style={layout.menu.img} source={require("@assets/ico-project.png")} />
								<Text style={layout.menu.txt}>Proyek</Text>
							</TouchableOpacity>
							*/}

							{(rootStore.my_permission.list_proyek) && !rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("projects")}>
									<Image style={layout.menu.img} source={require("@assets/ico-project.png")} />
									<Text style={layout.menu.txt}>Project</Text>
								</TouchableOpacity>
							}

							<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("tasks")}>
								<Image style={layout.menu.img} source={require("@assets/ico-task.png")} />
								<Text style={layout.menu.txt}>Tugas</Text>
							</TouchableOpacity>

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("forms")}>
									<Image style={layout.menu.img} source={require("@assets/ico-form.png")} />
									<Text style={layout.menu.txt}>Form</Text>
								</TouchableOpacity>
							)}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("tasks")}>
									<Image style={layout.menu.img} source={require("@assets/ico-asset.png")} />
									<Text style={layout.menu.txt}>Asset</Text>
								</TouchableOpacity>
							)}

							{(rootStore.my_permission.report_task) &&
								<TouchableOpacity style={layout.menu.box} onPress={workReportPage}>
									<Image style={layout.menu.img} source={require("@assets/ico-report.png")} />
									<Text style={layout.menu.txt}>Laporan Pengerjaan</Text>
								</TouchableOpacity>
							}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("meeting")}>
									<Image style={layout.menu.img} source={require("@assets/ico-status.png")} />
									<Text style={layout.menu.txt}>Meeting</Text>
								</TouchableOpacity>
							)}
							
							{/*<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("laporan")}>*/}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} 
									onPress={() => navigateTo("profile")}
									// onPress={() => doReport()}
								>
									<Image style={layout.menu.img} source={require("@assets/ico-complaint.png")} />
									<Text style={layout.menu.txt}>Laporan Masalah</Text>
								</TouchableOpacity>
							)}

							{(!rootStore.settings.offline_mode &&
								<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("otorisasi")}>
									<Image style={layout.menu.img} source={require("@assets/ico-meeting.png")} />
									<Text style={layout.menu.txt}>Otorisasi</Text>
								</TouchableOpacity>
							)}

							{/*
							<TouchableOpacity style={layout.menu.box} onPress={() => navigateTo("bootstrap")}>
								<Image style={layout.menu.img} source={require("@assets/ico-complaint.png")} />
								<Text style={layout.menu.txt}>Bootstrap</Text>
							</TouchableOpacity>
							*/}
						</View>
					)}
				</View>

				<Text text={CONFIG.APP_VERSION} style={{ marginVertical: 20, fontSize: 10, textAlign: "center" }} />

	        </ScrollView>

	    </View>
  	)
})